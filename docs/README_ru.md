Content extraction tool — python приложение для описания api или другого источника данных с помощью классов (получение) и peewee-моделей (хранение).

## Имплементация класса

Для реализации получения каких либо данных из API следует наследовать `executables.templates.representations`.

Для хранения метаинформации используется модель ContentUnit, для файловой используется StorageUnit. Последний отвечает за папку на диске, и может содержать больше чем один файл. Логика должна находиться в методе execute() (в других типах).

Класс должен называться Implementation, такое название будет использовано при импорте. Для избежания повторения имён при импорте из другого executable можно использовать `import ... as name`.

### Методы

Ниже перечислены внутренние методы скриптов:

#### Documentable

##### defineMeta()

Локализованные названия внутри класса

##### getStructure()

Возвращает структуру класса, его документацию и подмодули. Лучше не оверрайдить.

#### RecursiveDeclarable

##### declare()

Возвращает массив из классов аргументов, которые будут использоваться для валидации ввода. При вызове скрипта все аргументы будут сложены в один словарь из всех родительских классов, и из них будет идти сравнение, вот.

##### declareRecursive()

Собирает аргументы из родительских классов.

#### Runnable

##### getAvailableAt()

Массив, содержит названия контекстов при которых скрипт может быть вызван.

##### getRequiredModules()

Массив из pip-модулей, необходимых для работы скрипта.

#### Saveable

##### ContentUnit(), Collection(), StorageUnit(), ThumbnailUnit()

Создаёт сущность в названии и добавляет собственную пометку в SavedVia.

### ExecutableCall

При вызове создаётся ExecutableCall, который выполняет executable.

Для исполнения других скриптов используется скрипт Executables.Execute с параметом i.

Вызвать через консоль скрипт можно так:

- Сделать cd в папку с приложением, запустить `venv.ps1`.

- Выполнить `python act.py --i` с названием скрипта.

### ExecutableMap

При каждом запуске формируется словарь из executable's, сканируя папку executables/list. Подмодули добавляются как в общий список, так и внутрь основного скрипта.

### Типы скриптов

**Act** — любая логика, может возвращать что угодно

**Extractor** — логика для получения контента. Возвращает ItemsResponse который представляет список контент юнитов. Имеет опосредованное отношение к тому, что возвращает.

**Representation** — представляет собой api-объект. Способы получения себя у representation находятся в подмодулях. Отвечает за SavedVia в CU.

**Outer** — логика после выполнения другого скрипта. Ничего не должно возвращать.

**Receivation** — Extractor, но возвращает именно содержимое для representation.

**Service** — скрипт, но выполняется регулярно.

### execute()

В самом главном методе модели должны создаваться через методы типо `self.ContentUnit()`. После записи в них какой либо информации, должен быть вызван метод `await x.flush()`, что вызовет сохранение во временную базу данных. 
